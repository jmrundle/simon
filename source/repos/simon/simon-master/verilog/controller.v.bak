module controller (
	input clk,

	// from datapath
	input enter_pressed,
	input input_pressed,
	input input_released,
	input red_pulse,
	input green_pulse,
	input yellow_pulse,
	input blue_pulse,
	input raddr_eq_level,
	input raddr_eq_max,
	input waddr_eq_max,
	
	// to datapath
	output s_raddr,
	output en_raddr,
	output s_waddr,
	output en_waddr,
	output s_level,
	output en_level,
	output s_bg, 
	output en_bg,
	output en_rng,
	output en_audio,
	output res_wait_timer,
	output res_disp_timer
	);
	
	parameter INIT_SYSTEM		= 6'd0;
	parameter WAIT_SCREEN 		= 6'd1;
	parameter INIT_SEQ_GEN		= 6'd2;
	parameter GET_RAND_NUM 		= 6'd3;
	parameter INCR_WADDR		= 6'd3;
	parameter INIT_DISP			= 6'd4;
	parameter READ_MEM			= 6'd5;
	parameter WAIT_FOR_PULSE	= 6'd6;
	parameter RED_FLASH			= 6'd7;
	parameter YELLOW_FLASH		= 6'd8;
	parameter BLUE_FLASH		= 6'd9;
	parameter GREEN_FALSH		= 6'd10;
	parameter INCR_RADDR_1		= 6'd11;
	parameter RES_RADDR			= 6'd12;
	parameter WAIT_FOR_INPUT	= 6'd13;
	parameter WAIT_FOR_RELEASE	= 6'd14;
	parameter INCR_RADDR_2		= 6'd15;
	parameter INCR_LEVEL		= 6'd16;
	parameter FAIL_SCREEN		= 6'd17;
	parameter WIN_SCREEN		= 6'd18;


	reg [5:0] state, next_state;
	
	always @(posedge clk) begin
		if (rst)
			next_state <= INIT;
		else
			next_state <= state;
	end
	
	always @(*) begin
		en_waddr = 0;
		s_waddr	 = 0;
				
		en_raddr = 0;
		s_raddr	 = 0;

		en_level = 0;
		s_level  = 0;
		
		en_bg = 1;
		s_bg  = 0;

		en_rng = 0;

		en_audio = 0;
		
		res_wait_timer = 1;
		res_disp_timer = 1;
		
		next_state = state;

		
		case (state)
			
			INIT_SYSTEM: begin
				// level <= 1
				en_level = 1;
				s_level  = 1;
				
				// bg <= 0
				en_bg = 1;
				s_bg  = 0;

				next_state = WAIT_SCREEN;
			end

			WAIT_SCREEN: begin
				// bg <= 1
				en_bg = 1;
				s_bg  = 1;

				if (enter_pressed)
					next_state = INIT_SET_SEQ;
			end
			
			INIT_SEQ_GEN: begin
				// waddr <= 0
				en_waddr = 1;
				s_waddr  = 0;
			
				next_state = GET_RAND_NUM;
			end		

			GET_RAND_NUM:	begin
				// store rng in memory
				en_rng = 1;
				next_state = INCR_WADDR;
			end

			INCR_WADDR: begin
				// waddr <= waddr + 1
				en_waddr= 1;
				s_waddr = 1;
				
				if (addr_eq_max)
					next_state = INIT_DISP;
				else
					next_state = GET_RAND_NUM;
			end
			
			INIT_DISP: begin
				// raddr <= 0
				en_raddr = 1;
				s_raddr	= 0;
				
				next_state = READ_MEM;
			end

			READ_MEM: begin
				// synchronous memory
				next_state = WAIT_FOR_PULSE;
			end

			WAIT_FOR_PULSE: begin
				// enable wait timer
				res_wait_timer = 0;

				if (~wait_timer_pulse)
					next_state = WAIT_FOR_PULSE;
				else if (red_pulse)
					next_state = RED_FLASH;
				else if (green_pulse)
					next_state = GREEN_FLASH;
				else if (yellow_pulse)
					next_state = YELLOW_FLASH;
				else if (blue_pulse)
					next_state = BLUE_FLASH;
			end

			RED_FLASH: begin
				// enable disp timer
				res_disp_timer = 0;
				
				en_bg = 1;
				s_bg  = 2;

				if (input_pulse)
					next_state = INCR_RADDR_1;
			end

			YELLOW_FLASH: begin
				// enable disp timer
				res_disp_timer = 0;

				en_bg = 1;
				s_bg  = 3;

				if (input_pulse)
					next_state = INCR_RADDR_1;
			end

			GREEN_FLASH: begin
				// enable disp timer
				res_disp_timer = 0;

				en_bg = 1;
				s_bg  = 4;

				if (input_pulse)
					next_state = INCR_RADDR_1;
			end

			BLUE_FLASH: begin
				// enable disp timer
				res_disp_timer = 0;

				en_bg = 1;
				s_bg  = 5;

				if (input_pulse)
					next_state = INCR_RADDR_1;
			end

			INCR_RADDR_1: begin
				// raddr <= raddr + 1
				en_raddr = 1;
				s_raddr  = 1;

				if (raddr_eq_level)
					next_state = INIT_GAME;
				else
					next_state = READ_MEM;
			end
			
			RES_RADDR: begin	
				// raddr <= 0
				en_raddr = 1;
				s_raddr	= 0;
				
				next_state = WAIT_FOR_INPUT;
			end
			
			WAIT_FOR_INPUT: begin
				if (input_pressed)
					next_state = INCR_RADDR_2;
				else
					next_state = WAIT_FOR_INPUT;
			end

			WAIT_FOR_RELEASE: begin
				en_audio = 1;

				if (input_released)
					next_state = INCR_RADDR_2;
				else
					next_state = WAIT_FOR_RELEASE;
			end
			
			INCR_RADDR_2: begin	
				// raddr <= raddr + 1;
				en_raddr = 1;
				s_raddr  = 1;
				
				if (correct && addr_eq_level)
					next_state = INCR_LEVEL;
				else if (correct && ~addr_eq_level)
					next_state = WAIT_FOR_INPUT;
				else if (~correct)
					next_state = FAIL_SCREEN;
			end
			
			INCR_LEVEL: begin
				// level <= level + 1;
				en_level = 1;
				s_level  = 1;
				
				if (level_eq_max)
					next_state = WIN_SCREEN;
				else
					next_state = RES_RADDR;
			end
			
			FAIL_SCREEN: begin	
				en_bg = 1;
				s_bg  = 6;
				
				if (enter_pressed)
					next_state = WAIT_SCREEN;
				else
					next_state = FAIL_SCREEN;
			end
			
			WIN_SCREEN: begin
				en_bg = 1;
				s_bg  = 7;
				
				if (enter_pressed)
					next_state = WAIT_SCREEN;
				else
					next_state = WIN_SCREEN;
			end
			
			default: begin
				next_state = INIT_SYSTEM;
			end
		
		endcase
	
	end

endmodule
