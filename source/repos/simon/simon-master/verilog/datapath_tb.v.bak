`timescale 1ns/1ns
module datapath_tb();


datapath uut(

	);






reg clk;
	
	// from VGA controller (using 320x240 resolution) to decide which color to use for each pixel
	reg [2:0]	xvga;
	reg [2:0]	yvga;
	
	// from RAM
	reg [1:0] dout;			// data being pointed to by raddr
	
	// from Keyboard controller
	reg 		make;
	reg [7:0] keycode;
	
	// from controller
	reg s_raddr;
	reg en_raddr;
	reg s_waddr;
	reg en_waddr;
	reg s_level;
	reg en_level;
	reg [3:0] s_bg; 
	reg en_bg;
	reg en_rng;
	reg en_audio;
	reg res_wait_timer;
	reg res_disp_timer;
	
	// to controller
	wire enter_pressed;
	wire key_pressed;
	wire valid_reg;
	wire red_pulse;
	wire green_pulse;
	wire yellow_pulse;
	wire blue_pulse;
	wire raddr_eq_level;
	wire waddr_eq_max;
	wire raddr_eq_max;
	wire level_eq_max;
	wire correct;
	wire wait_timer_pulse;
	wire disp_timer_pulse;
	
	
	// to RAM
	wire 		 		we;		// should we store data in RAM?
	wire 	  [1:0] 	din; 		// data to be stored in RAM (rng)
	wire [7:0] 	raddr; 	// addr to get data in RAM
	wire [7:0] 	waddr; 	// addr to write data in RAM

	// color to send to VGA controller
	wire [7:0] 	color;
	
	
	
	always #2 clk <= ~clk;

	initial begin
		clk = 0; s_raddr = 0; en_raddr = 1; s_waddr = 0; en_waddr = 1;
		s_level = 0; en_level = 0; s_bg = 0; en_bg = 1; en_rng = 1;
		en_audio = 0; res_wait_timer = 0; res_disp_timer = 0;
		
		#10 en_audio = 1; en_rng = 0;
		#10 en_audio = 0;
		#10 en_level = 1;
		#10 en_level = 0;
		#10 s_level = 1; en_level = 1; s_waddr = 1; s_raddr = 1;
		#200 res_wait_timer = 1;
		#10 res_wait_timer = 0;
		#200 res_disp_timer = 1;
		#10 res_disp_timer = 0;
		#200 en_level = 0;
		#100 en_bg = 0;
		#100 en_level = 1;
		#100 s_waddr = 0;
		#100 s_raddr = 0;
		#100 s_waddr = 1;
		#100;
	
	
	
	
	
	$stop;
	end
	
	
endmodule